[{"title":"前端开发的历史和趋势","date":"2017-01-12T21:00:29.000Z","path":"2017/01/13/前端开发的历史和趋势/","text":"本文转载自阮一峰 前端开发的历史和趋势 什么是前端 前端：针对浏览器的开发，代码在浏览器运行 后端：针对服务器的开发，代码在服务器运行 前后端不分的时代互联网发展的早期，前后端开发是一体的，前端代码是后端代码的一部分。 后端收到浏览器的请求 生成静态页面 发送到浏览器 后端 MVC 的开发模式那时的网站开发，采用的是后端 MVC 模式。 Model（模型层）：提供/保存数据 Controller（控制层）：数据处理，实现业务逻辑 View（视图层）：展示数据，提供用户界面 前端只是后端 MVC 的 V。 以 PHP 框架 Laravel 为例。 前端工程师的角色那时的前端工程师，实际上是模板工程师，负责编写页面模板。 后端代码读取模板，替换变量，渲染出页面。 典型的 PHP 模板1234567891011&lt;html&gt; &lt;head&gt;&lt;title&gt;Car &#123;&#123; $car-&gt;id &#125;&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Car &#123;&#123; $car-&gt;id &#125;&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Make: &#123;&#123; $car-&gt;make &#125;&#125;&lt;/li&gt; &lt;li&gt;Model: &#123;&#123; $car-&gt;model &#125;&#125;&lt;/li&gt; &lt;li&gt;Produced on: &#123;&#123; $car-&gt;produced_on &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; AjaxAjax 技术诞生，改变了一切。 2004年：Gmail 2005年：Google 地图 前端不再是后端的模板，可以独立得到各种数据。 Web 2.0Ajax 技术促成了 Web 2.0 的诞生。 Web 1.0：静态网页，纯内容展示 Web 2.0：动态网页，富交互，前端数据处理 从那时起，前端变得复杂了，对前端工程师的要求越来越高。 前端 MVC 框架前端通过 Ajax 得到数据，因此也有了处理数据的需求。 前端代码变得也需要保存数据、处理数据、生成视图，这导致了前端 MVC 框架的诞生。 2010年，Backbone.js Backbone.jsBackbone 将前端代码分成两个基本部分。 Model：管理数据 View：数据的展现 前端 ControllerBackbone 只有 M 和 V，没有 C。因为，前端 Controller 与后端不同。 不需要，也不应该处理业务逻辑 只需要处理 UI 逻辑，响应用户的一举一动 所以，前端 Controller 相对比较简单。Backbone 没有 C，只用事件来处理 UI 逻辑。 12345678var AppView = Backbone.View.extend(&#123; // ... events: &#123; \"keypress #new-todo\": \"createOnEnter\", \"click #clear-completed\": \"clearCompleted\", \"click #toggle-all\": \"toggleAllComplete\" &#125;,&#125;); Router前端还有一种天然的方法，可以切换视图，那就是 URL。 通过 URL 切换视图，这就是 Router（路由）的作用。以 Backbone 为例。 123456789101112App.Router = Backbone.Router.extend(&#123; routes: &#123; '': 'index', 'show': 'show' &#125;, index: function () &#123; $(document.body).append(\"调用了 Index 路由\"); &#125;, show: function () &#123; $(document.body).append(\"调用了 Show 路由\"); &#125;,&#125;); MVVM 模式另一些框架提出 MVVM 模式，用 View Model 代替 Controller。 Model View View-Model：简化的 Controller，唯一作用就是为 View 提供处理好的数据，不含其他逻辑。 本质：view 绑定 view-model，视图与数据模型强耦合。数据的变化实时反映在 view 上，不需要手动处理。 SPA前端可以做到： 读写数据 切换视图 用户交互 这意味着，网页其实是一个应用程序。 SPA = Single-page application 2010年后，前端工程师从开发页面，变成了开发”前端应用“（跑在浏览器里面的应用程序）。 传统的架构 单页应用的架构 多了一个前端 MVC 层 AngularGoogle 公司推出的 Angular 是最流行的 MVVM 前端框架。 它的风格属于 HTML 语言的增强，核心概念是双向绑定。 示例：Angular 的双向绑定 1234567&lt;div ng-app=\"\"&gt; &lt;p&gt; 姓名 : &lt;input type=\"text\" ng-model=\"name\" placeholder=\"在这里输入您的大名\"&gt; &lt;/p&gt; &lt;h1&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt; VueVue.js 是现在很热门的一种前端 MVVM 框架。 它的基本思想与 Angular 类似，但是用法更简单，而且引入了响应式编程的概念。 示例：Vue 的双向绑定Vue 的模板与数据，是双向绑定的。 HTML 代码 1234&lt;div id=\"journal\"&gt; &lt;input type=\"text\" v-model=\"message\"&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;/div&gt; JS 代码 123456var journal = new Vue(&#123; el: '#journal', data: &#123; message: 'Your first entry' &#125;&#125;); 前后端分离 Ajax -&gt; 前端应用兴起 智能手机 -&gt; 多终端支持 这两个原因，导致前端开发方式发生根本的变化。 前端不再是后端 MVC 中的 V，而是单独的一层。 REST 接口前后端分离以后，它们之间通过接口通信。 后端暴露出接口，前端消费后端提供的数据。 后端接口一般是 REST 形式，前后端的通信协议一般是 HTTP。 Node2009年，Node 项目诞生，它是服务器上的 JavaScript 运行环境。 Node = JavaScript + 操作系统 API Node 的意义 JavaScript 成为服务器脚本语言，与 Python 和 Ruby 一样 JavaScript 成为唯一的浏览器和服务器都支持的语言 前端工程师可以编写后端程序了 前端开发模式的根本改变 Node 环境下开发 大量使用服务器端工具 引入持续集成等软件工程的标准流程 开发完成后，编译成浏览器可以运行的脚本，放上 CDN 全栈工程师前端工程师正在转变为全栈工程师 一个人负责开发前端和后端 从数据库到 UI 的所有开发 全栈技能怎样才能称为全栈工程师？ 传统前端技能：HTML、JavaScript、CSS 一门后端语言 移动端开发：iOS / Android / HTML5 其他技能：数据库、HTTP 等等 软件行业的发展动力历史演变：前后端不分 -&gt; 前后端分离 -&gt; 全栈工程师 动力：更加产业化、大规模地生产软件 效率更高 成本更低 通用性好、能够快速产出的技术最终会赢，单个程序员的生产力要求越来越高。 H5 就是一个最好的例子为什么 H5 技术会赢得移动端？ 开发速度快：Native 需要重新编译才能看到结果，H5 是即时输出 开发成本低：Native 需要两个开发团队，H5 只要一个 快速发布：安卓 Native 新版本需要24小时，iOS 需要 3 ～ 4 天，H5 可以随时更新 未来软件的特点 联网 高并发 分布式 跨终端 现在基于 Web 的前端技术，将演变为未来所有软件的通用的 GUI 解决方案。 未来只有两种软件工程师 端工程师 手机端 PC 端 TV 端 VR 端 …… 云工程师","tags":[{"name":"Frontend","slug":"Frontend","permalink":"http://yoursite.com/tags/Frontend/"},{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/tags/Chinese/"}]},{"title":"JavaScript闭包详解","date":"2017-01-10T13:30:00.000Z","path":"2017/01/10/JavaScript闭包详解/","text":"本文转载自MDN 词法作用域考虑如下的函数: (JSFiddle) function init() { var name = &quot;Mozilla&quot;; function displayName() { alert(name); } displayName(); } init(); 函数 init() 创建了一个局部变量 name，然后定义了名为 displayName() 的函数。 displayName() 是一个内部函数——定义于 init() 之内且仅在该函数体内可用。displayName() 没有任何自己的局部变量，然而它可以访问到外部函数的变量，即可以使用父函数中声明的 name 变量。 运行代码可以发现这可以正常工作。这是词法作用域的一个例子：在 JavaScript 中，变量的作用域是由它在源代码中所处位置决定的（显然如此），并且嵌套的函数可以访问到其外层作用域中声明的变量。 闭包现在来考虑如下的例子： function makeFunc() { var name = &quot;Mozilla&quot;; function displayName() { alert(name); } return displayName; } var myFunc = makeFunc(); myFunc(); 运行这段代码的效果和之前的 init() 示例完全一样：字符串 &quot;Mozilla&quot; 将被显示在一个 JavaScript 警告框中。其中的不同 — 也是有意思的地方 — 在于 displayName() 内部函数在执行前被从其外围函数中返回了。 这段代码看起来别扭却能正常运行。通常，函数中的局部变量仅在函数的执行期间可用。一旦 makeFunc() 执行过后，我们会很合理的认为 name 变量将不再可用。虽然代码运行的没问题，但实际并不是这样的。 这个谜题的答案是 myFunc 变成一个 闭包 了。 闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，myFunc 是一个闭包，由 displayName 函数和闭包创建时存在的 &quot;Mozilla&quot; 字符串形成。 下面是一个更有意思的示例 — makeAdder 函数： function makeAdder(x) { return function(y) { return x + y; }; } var add5 = makeAdder(5); var add10 = makeAdder(10); console.log(add5(2)); // 7 console.log(add10(2)); // 12 在这个示例中，我们定义了 makeAdder(x) 函数：带有一个参数 x 并返回一个新的函数。返回的函数带有一个参数 y，并返回 x 和 y 的和。 从本质上讲，makeAdder 是一个函数工厂 — 创建将指定的值和它的参数求和的函数，在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。 add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。 实用的闭包理论就是这些了 — 可是闭包确实有用吗？让我们看看闭包的实践意义。闭包允许将函数与其所操作的某些数据（环境）关连起来。这显然类似于面向对象编程。在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。 因而，一般说来，可以使用只有一个方法的对象的地方，都可以使用闭包。 在 Web 中，您可能想这样做的情形非常普遍。大部分我们所写的 Web JavaScript 代码都是事件驱动的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常添加为回调：响应事件而执行的函数。 以下是一个实际的示例：假设我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其它元素（例如页眉）的字号：(JSFiddle) body { font-family: Helvetica, Arial, sans-serif; font-size: 12px; } h1 { font-size: 1.5em; } h2 { font-size: 1.2em; } 我们的交互式的文本尺寸按钮可以修改 body 元素的 font-size 属性，而由于我们使用相对的单位，页面中的其它元素也会相应地调整。 以下是 JavaScript： function makeSizer(size) { return function() { document.body.style.fontSize = size + &apos;px&apos;; }; } var size12 = makeSizer(12); var size14 = makeSizer(14); var size16 = makeSizer(16); size12，size14 和 size16 为将 body 文本相应地调整为 12，14，16 像素的函数。我们可以将它们分别添加到按钮上（这里是链接）。如下所示： document.getElementById(&apos;size-12&apos;).onclick = size12; document.getElementById(&apos;size-14&apos;).onclick = size14; document.getElementById(&apos;size-16&apos;).onclick = size16; &lt;a href=&quot;#&quot; id=&quot;size-12&quot;&gt;12&lt;/a&gt; &lt;a href=&quot;#&quot; id=&quot;size-14&quot;&gt;14&lt;/a&gt; &lt;a href=&quot;#&quot; id=&quot;size-16&quot;&gt;16&lt;/a&gt; 用闭包模拟私有方法诸如 Java 在内的一些语言支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。 对此，JavaScript 并不提供原生的支持，但是可以使用闭包模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。 下面的示例展现了如何使用闭包来定义公共函数，且其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）： var Counter = (function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } } })(); console.log(Counter.value()); /* logs 0 */ Counter.increment(); Counter.increment(); console.log(Counter.value()); /* logs 2 */ Counter.decrement(); console.log(Counter.value()); /* logs 1 */ 这里有很多细节。在以往的示例中，每个闭包都有它自己的环境；而这次我们只创建了一个环境，为三个函数所共享：Counter.increment，Counter.decrement 和 Counter.value。 该共享环境创建于一个匿名函数体内，该函数一经定义立刻执行。环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。 这两项都无法在匿名函数外部直接访问。必须通过匿名包装器返回的三个公共函数访问。 这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法范围的作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。 您应该注意到了，我们定义了一个匿名函数用于创建计数器，然后直接调用该函数，并将返回值赋给 Counter 变量。也可以将这个函数保存到另一个变量中，以便创建多个计数器。 var makeCounter = function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } } }; var Counter1 = makeCounter(); var Counter2 = makeCounter(); console.log(Counter1.value()); /* logs 0 */ Counter1.increment(); Counter1.increment(); console.log(Counter1.value()); /* logs 2 */ Counter1.decrement(); console.log(Counter1.value()); /* logs 1 */ console.log(Counter2.value()); /* logs 0 */ 请注意两个计数器是如何维护它们各自的独立性的。每次调用 makeCounter() 函数期间，其环境是不同的。每次调用中， privateCounter 中含有不同的实例。 这种形式的闭包提供了许多通常由面向对象编程U所享有的益处，尤其是数据隐藏和封装。 在循环中创建闭包：一个常见错误在 JavaScript 1.7 引入 let 关键字 之前，闭包的一个常见的问题发生于在循环中创建闭包。参考下面的示例：(JSFiddle) &lt;p id=&quot;help&quot;&gt;Helpful notes will appear here&lt;/p&gt; &lt;p&gt;E-mail: &lt;input type=&quot;text&quot; id=&quot;email&quot; name=&quot;email&quot;&gt;&lt;/p&gt; &lt;p&gt;Name: &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot;&gt;&lt;/p&gt; &lt;p&gt;Age: &lt;input type=&quot;text&quot; id=&quot;age&quot; name=&quot;age&quot;&gt;&lt;/p&gt; function showHelp(help) { document.getElementById(&apos;help&apos;).innerHTML = help; } function setupHelp() { var helpText = [ {&apos;id&apos;: &apos;email&apos;, &apos;help&apos;: &apos;Your e-mail address&apos;}, {&apos;id&apos;: &apos;name&apos;, &apos;help&apos;: &apos;Your full name&apos;}, {&apos;id&apos;: &apos;age&apos;, &apos;help&apos;: &apos;Your age (you must be over 16)&apos;} ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); } } } setupHelp(); 数组 helpText 中定义了三个有用的提示信息，每一个都关联于对应的文档中的输入域的 ID。通过循环这三项定义，依次为每一个输入域添加了一个 onfocus 事件处理函数，以便显示帮助信息。 运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个输入域上，显示的都是关于年龄的消息。 该问题的原因在于赋给 onfocus 是闭包（setupHelp）中的匿名函数而不是闭包对象；在闭包（setupHelp）中一共创建了三个匿名函数，但是它们都共享同一个环境（item）。在 onfocus 的回调被执行时，循环早已经完成，且此时 item 变量（由所有三个闭包所共享）已经指向了 helpText 列表中的最后一项。 解决这个问题的一种方案是使 onfocus 指向一个新的闭包对象。(JSFiddle) function showHelp(help) { document.getElementById(&apos;help&apos;).innerHTML = help; } function makeHelpCallback(help) { return function() { showHelp(help); }; } function setupHelp() { var helpText = [ {&apos;id&apos;: &apos;email&apos;, &apos;help&apos;: &apos;Your e-mail address&apos;}, {&apos;id&apos;: &apos;name&apos;, &apos;help&apos;: &apos;Your full name&apos;}, {&apos;id&apos;: &apos;age&apos;, &apos;help&apos;: &apos;Your age (you must be over 16)&apos;} ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = makeHelpCallback(item.help); } } setupHelp(); 这段代码可以如我们所期望的那样工作。所有的回调不再共享同一个环境， makeHelpCallback 函数为每一个回调创建一个新的环境。在这些环境中，help 指向 helpText 数组中对应的字符串。 性能考量如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用，方法都会被重新赋值一次（也就是说，为每一个对象的创建）。 考虑以下虽然不切实际但却说明问题的示例： function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); this.getName = function() { return this.name; }; this.getMessage = function() { return this.message; }; } 上面的代码并未利用到闭包的益处，因此，应该修改为如下常规形式： function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); } MyObject.prototype = { getName: function() { return this.name; }, getMessage: function() { return this.message; } }; 或者改成： function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); } MyObject.prototype.getName = function() { return this.name; }; MyObject.prototype.getMessage = function() { return this.message; }; 下面的代码可以更简洁的实现同样效果 function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); } (function() { this.getName = function() { return this.name; }; this.getMessage = function() { return this.message; }; }).call(MyObject.prototype); 在前面的三个示例中，继承的原型可以为所有对象共享，且不必在每一次创建对象时定义方法。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript语言精粹笔记","date":"2017-01-08T13:30:00.000Z","path":"2017/01/08/JavaScript语言精粹笔记/","text":"对象通过引用来传递，它们永远不会被复制。 12345var x= stooge;x.nickName = &apos;Curly&apos;;var nick = stooge.nickName; //因为x和stooge是指向同一个对象的引用，所以nick为&apos;Curly&apos;var a = &#123;&#125;, b = &#123;&#125;, c = &#123;&#125;; //a, b 和 c 每个都引用一个不同的空对象a = b= c = &#123;&#125;; //a, b 和 c 都引用同一个空对象 每个对象都连接到一个原型对象，并且它可以从中继承属性。所有通过对象字面量创建的对象都连接到Object.prototype，它是JavaScript中的标配对象。 全局变量削弱了程序的灵活性，应该避免使用。最小化使用全局变量的方法之一是为你的应用只创建一个唯一的全局变量： var MYAPP = {} ，所有变量都存入该对象中。 当今大多数语言都是基于类的语言，而JavaScript是一门基于原型继承的语言，这意味着对象可以直接从其他对象继承属性。 一个函数总是会返回一个值，如果没有指定返回值，则返回undefined，如果函数调用时在前面加上了new前缀，则返回this，指向该新对象。 大多数类C语言的语言都拥有块级作用域，即在一个代码块中（括在一对花括号中的一组语句）定义的所有变量在代码块的外部是不可见的，但是JavaScript实际上并不支持块级作用域，只有函数作用域。很多语言推荐尽可能延迟声明变量，而对于JavaScript，由于它缺少块级作用域，所以最好的做法是在函数体的顶部声明函数中可能用到的所有变量。 在循环中创建函数只会带来无谓的计算，还会引起混淆，所以应该避免在循环中创建函数。 JavaScript中的 array 和 object 类似，与传统的线性分配内存的数组不同。允许数组包含任意混合类型的值。 JavaScript中的 array 的 length 属性的值是这个数组的最大整数属性名加上1，不一定等于数组里的属性的个数： 1234var myArray = [];myArray.length // 0 此时数组为空myArray[100] = &apos;abc&apos;; // 属性名为100，即下标myArray.length // 101 此时数组只包含一个属性 JavaScript中数组和对象没有本质上的区别，而至于是使用数组还是对象的规则为：当属性名是小而连续的整数时，就应该使用数组，否则使用对象。 JavaScript有两组相等运算符：=== 和 !== ，以及 == 和 != 。前者会按照你期望的方式工作，如果两个运算数类型一致且值相同，那么 === 返回 true ， != 返回 false 。而后者只有在两个运算数类型一致时才会做出正确的判断，如果两个运算数是不同的类型，它们试图去强制转换值的类型。因此建议永远不要使用 == 和 != ，只用 === 和 !==。 JavaScript中应该避免使用 ++ 、-- 、位运算符、new 、void 。 JavaScript中的 for in 语句可以用来遍历对象的所有属性的名字，但是它也会遍历出所有从原型链中继承而来的成员属性，所以每个 for in 语句的主体应该被包围在一个用于过滤的 if 语句中，用来排除函数或者从原型继承而来的属性。 12345for (name in object) &#123; if (object.hasOwnProperty(name)) &#123; ... &#125;&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Markdown Usage","date":"2017-01-05T13:30:00.000Z","path":"2017/01/05/Markdown Usage/","text":"概述宗旨Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 兼容HTMLMarkdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些HTML块元素—比如div、table、pre、p等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的p标签。 例子如下，在 Markdown 文件里加上一段 HTML 表格： 123456789这是一个普通段落。&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的 强调 会没有效果。 HTML的行元素如span、cite、del 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的a或img标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在HTML区块标签间不同，Markdown语法在HTML区段标签间是有效的。 区块元素段落和换行一个Markdown段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行。普通段落不该用空格或制表符来缩进。 ‘由一个或多个连续的文本行组成’这句话暗示了Markdown允许段落内的强迫换行（插入换行符），这个特性和其他大部分的text-to-HTML格式不一样，其它的格式会把每个换行符都转成&lt;br /&gt;标签。 如果你确实想要依赖Markdown来插入&lt;br /&gt;标签的话，在插入处先按入两个以上的空格然后回车。 标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： 12345This is an H1=============This is an H2------------- 任何数量的 = 和 - 都可以有效果。 类 Atx 形式类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： 12345# 这是 H1## 这是 H2###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： 12345# 这是 H1 ### 这是 H2 ##### 这是 H3 ###### 区块引用Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： 12345&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 12345678&gt; ## 这是一个标题。&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。 列表Markdown 支持有序列表和无序列表。 无序列表使用星号 * 、加号 + 或是减号 - 作为列表标记： 123* Red* Green* Blue 等同于： 123+ Red+ Green+ Blue 也等同于： 123- Red- Green- Blue 有序列表则使用数字接着一个英文句点： 1231. Bird2. McHale3. Parish 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1234567891. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： 1234* A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： 123* 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法： 11986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 11986\\. What a great season. 代码区块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 pre 和 code 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以。 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： 123456789* * *********- - ---------------------------------------- 区段元素链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 行内式要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： 123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. 如果你是要链接到同样主机的资源，你可以使用相对路径： 1See my [About](/about/) page for details. 参考式参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： 1This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： 1This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： 1[id]: http://example.com/ &quot;Optional Title Here&quot; 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 参考式的链接其实重点不在于它比较好写，而是它比较好读，使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;，例如： 1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。 强调也可以直接插在文字中间： 1un*frigging*believable 但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： 1\\*this text is surrounded by literal asterisks\\* 代码如果要标记一小段行内代码，你可以用反引号把它包起来（` ），例如： 1Use the `printf()` function. 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： 1``There is a literal backtick (`) here.`` 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： 123A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` `` 图片很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式行内式的图片语法看起来像是： 123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 参考式参考式的图片语法则长得像这样： 1![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 1[id]: url/to/image &quot;Optional title attribute&quot; 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 其它自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： 1&lt;http://example.com/&gt; 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： 1&lt;address@example.com&gt; 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），你可以在星号的前面加上反斜杠： 1\\*literal asterisks\\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号","tags":[{"name":"Usage","slug":"Usage","permalink":"http://yoursite.com/tags/Usage/"},{"name":"Introduction","slug":"Introduction","permalink":"http://yoursite.com/tags/Introduction/"}]},{"title":"Hexo Usage","date":"2017-01-01T08:55:29.000Z","path":"2017/01/01/Hexo Usage/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Usage","slug":"Usage","permalink":"http://yoursite.com/tags/Usage/"}]}]